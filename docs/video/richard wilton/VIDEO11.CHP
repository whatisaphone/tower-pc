


                    11  Bit Blocks and Animation


                           Bit Block Move
           CGA and MCGA ş EGA and VGA ş HGC ş InColor Card

                      Bitwise Pixel Operations
                        XOR ş NOT ş AND ş OR


                          Bit Block Tiling

                              Animation
                            XOR Animation
                     Overlapping Bit Block Moves

                       A Graphics-Mode Cursor
                        XOR ş Bit Block Move



     This chapter is about moving things around in the video buffer and on
     the screen. Some of the most useful and entertaining graphics-mode
     programs create the appearance of on-screen motion. Objects as mundane
     as a cursor or as unusual as an alien spaceship can appear to move
     across the screen if you erase them and then immediately redraw them
     in successive locations. PC and PS/2 video subsystems are not
     particularly well equipped to support this kind of real-time
     animation, but the techniques in this chapter should help you fully
     exploit their capabilities.

     You might think of video animation in the same context as video games,
     but animation has other uses in computer graphics. For instance, all
     interactive graphics programs require a moving cursor that allows the
     user to point to screen locations. Many drawing or design programs let
     the user move shapes and images around the screen. Robotic control
     programs indicate the status of a robot arm with an animated
     representation of its position. You can create such animation effects
     using the techniques in this chapter.


Bit Block Move


     The basic software tool for many animation techniques is the bit block
     move--a routine that copies a rectangular block of pixels into, out
     of, or within the video buffer. The name "bit block move" describes
     this routine well. After all, a rectangle of pixels is in essence
     nothing more than a block of bits. Still, a bit block move routine can
     do more than simply copy pixel values. As can other video graphics
     drawing routines, a bit block move routine can update pixel values
     using the bitwise logical operations AND, OR, and XOR. These
     operations can create attractive effects when used as part of bit
     block moves.

     To copy a bit block from one location to another within the video
     buffer in PC and PS/2 video subsystems, it is usually more efficient
     to use an intermediate buffer in system RAM. You first copy pixel
     values from the video buffer into the intermediate buffer, then copy
     the values from this buffer to the desired position in the video
     buffer.

     Creating an intermediate copy of the pixels in a bit block might seem
     superfluous, but in most situations it is preferable to trying to move
     the bit block entirely within the video buffer. For example, neither
     the EGA nor the InColor Card supports direct logical operations (AND,
     OR, and XOR) between pixels in the bit planes. Also, CPU accesses to
     video RAM are slower than equivalent accesses to system RAM. Thus,
     when multiple copies of the same bit block are to be stored in the
     video buffer, making a single copy in system RAM and then making
     multiple copies from system RAM to video RAM is more efficient.


CGA and MCGA

     Listing 11-1 is a bit block move routine for the CGA. The routine
     GetBitBlock() copies a block of pixels from the video buffer to a
     buffer in system RAM. The complementary routine StoreBitBlock(), in
     Listing 11-2, copies pixels from system RAM to the video buffer.
     StoreBitBlock()contains subroutines to perform AND, OR, or XOR
     operations on the pixels in system RAM using the previous contents of
     the video buffer.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-1.  A routine to copy a block of pixels from the CGA video
     buffer to system RAM.

		TITLE	'Listing 11-1'
		NAME	GetBitBlock06
		PAGE	55,132

;
; Name:		GetBitBlock06
;
; Function:	Copy bit block from video buffer to system RAM
;		 in 640x200 2-color mode
;
; Caller:	Microsoft C:
;
;			int GetBitBlock06(x0,y0,x1,y1,buf);
;
;			     int x0,y0;    /* upper left corner of bit block */
;			     int x1,y1;       /* lower right corner */
;			     char far *buf;   /* buffer */
;
; Notes:	Returns size of bit block in system RAM.
;


ARGx0		EQU	word ptr [bp+4]
ARGy0		EQU	word ptr [bp+6]
ARGx1		EQU	word ptr [bp+8]
ARGy1		EQU	word ptr [bp+10]
ADDRbuf		EQU	         [bp+12]

VARPixelRows	EQU	word ptr [bp-2]
VARPixelRowLen	EQU	word ptr [bp-4]
VARincr		EQU	word ptr [bp-6]

ByteOffsetShift	EQU	3		; reflects number of pixels per byte


_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT

		EXTRN	PixelAddr06:near

		PUBLIC	_GetBitBlock06
_GetBitBlock06	PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		sub	sp,6		; establish stack frame
		push	ds
		push	si
		push	di

; compute dimensions of bit block

		mov	ax,ARGx1
		sub	ax,ARGx0
		mov	cx,0FF07h	; CH := unshifted bit mask
					; CL := AND mask for AL
		and	cl,al		; CL := number of pixels in last
					;  byte of row
		xor	cl,7		; CL := number of bits to shift
		shl	ch,cl		; CH := bit mask for last byte of row
		mov	cl,ch
		push	cx		; save on stack

		mov	cl,ByteOffsetShift
		shr	ax,cl
		inc	ax		; AX := number of bytes per row
		push	ax		; save on stack

		mov	ax,ARGy1
		sub	ax,ARGy0
		inc	ax		; AX := number of pixel rows
		push	ax		; save on stack

; establish addressing

		mov	ax,ARGy0
		mov	bx,ARGx0
		call	PixelAddr06	; ES:BX -> x0,y0 in video buffer
		xor	cl,7		; CL := number of bits to shift left
		push	es
		pop	ds
		mov	si,bx		; DS:SI -> video buffer

		mov	bx,2000h	; BX := increment from 1st to 2nd
					;  interleave in CGA video buffer
		test	si,2000h
		jz	L01		; jump if x0,y0 is in 1st interleave

		mov	bx,80-2000h	; increment from 2nd to 1st interleave

L01:		mov	VARincr,bx	; initialize this variable

		les	di,ADDRbuf	; ES:DI -> buffer in system RAM

; build 5-byte bit block header

		pop	ax
		mov	VARPixelRows,ax
		stosw			; byte 0-1 := number of pixel rows
		pop	ax
		mov	VARPixelRowLen,ax
		stosw			; byte 2-3 := bytes per pixel row
		pop	ax
		mov	ch,al		; CH := bit mask for last byte
		stosb			; byte 4 := bit mask for last byte

; copy from video buffer to system RAM

L02:		mov	bx,VARPixelRowLen
		push	si		; preserve SI at start of pixel row

L03:		lodsw			; AL := next byte in video buffer
					; AH := (next byte) + 1
		dec	si		; DS:SI -> (next byte) + 1
		rol	ax,cl		; AL := next 4 pixels in row
		stosb			; copy to system RAM
		dec	bx		; loop across row
		jnz	L03

		and	es:[di-1],ch	; mask last byte of row		
		pop	si		; DS:SI -> start of row
		add	si,VARincr	; DS:SI -> start of next row
		xor	VARincr,2000h XOR (80-2000H)  ; update increment

		dec	VARPixelRows
		jnz	L02		; loop down rows

		mov	ax,di
		sub	ax,ADDRbuf	; AX := return value (size of bit block
					;  in system RAM)

		pop	di		; restore registers and exit
		pop	si
		pop	ds
		mov	sp,bp
		pop	bp
		ret

_GetBitBlock06	ENDP

_TEXT		ENDS

		END

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-2.  A routine to copy a block of pixels from system RAM to
     the CGA video buffer.

		TITLE	'Listing 11-2'
		NAME	StoreBitBlock06
		PAGE	55,132

;
; Name:		StoreBitBlock06
;
; Function:	Copy bit block from video buffer to system RAM
;		 in 640x200 2-color mode
;
; Caller:	Microsoft C:
;
;			void StoreBitBlock06(buf,x,y);
;
;			     char far *buf;   /* buffer */
;			     int x,y;    /* upper left corner of bit block */
;


ADDRbuf		EQU	dword ptr [bp+4]
ARGx		EQU	word ptr [bp+8]
ARGy		EQU	word ptr [bp+10]

VARPixelRows	EQU	word ptr [bp-2]
VARPixelRowLen	EQU	word ptr [bp-4]
VARincr		EQU	word ptr [bp-6]


DGROUP		GROUP	_DATA

_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT,ds:DGROUP

		EXTRN	PixelAddr06:near

		PUBLIC	_StoreBitBlock06
_StoreBitBlock06 PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		sub	sp,6		; establish stack frame
		push	ds
		push	si
		push	di

; establish addressing

		mov	ax,ARGy
		mov	bx,ARGx
		call	PixelAddr06	; ES:BX -> byte offset of x,y
		xor	cl,7		; CL := number of bits to shift right

		mov	di,bx		; ES:DI -> x,y in video buffer
		
		mov	bx,2000h	; BX := increment from 1st to 2nd
					;  interleave in CGA video buffer
		test	di,2000h
		jz	L01		; jump if x,y is in 1st interleave

		mov	bx,80-2000h	; increment from 2nd to 1st interleave

L01:		mov	VARincr,bx	; initialize this variable

		mov	bx,StoreBitBlockOp  ; BX := subroutine address

		lds	si,ADDRbuf	; ES:DI -> buffer in system RAM

; obtain dimensions of bit block from header

		lodsw			; AX := number of pixel rows
		mov	VARPixelRows,ax
		lodsw			; AX := bytes per pixel row
		mov	VARPixelRowLen,ax
		lodsb			; AL := bit mask for last byte in row
		mov	ch,al

		jmp	bx		; jump to subroutine


ReplaceBitBlock:
		cmp	cx,0FF00h	; if mask <> 0FFH or bits to shift <> 0
		jne	L15		;  jump if not byte-aligned

; routine for byte-aligned bit blocks

		mov	cx,VARPixelRowLen

L10:		push	di		; preserve DI and CX
		push	cx
		rep	movsb		; copy one pixel row into video buffer
		pop	cx		; restore DI and CX
		pop	di	
		add	di,VARincr	; ES:DI -> next pixel row in buffer
		xor	VARincr,2000h XOR (80-2000h) ; update increment
		dec	VARPixelRows
		jnz	L10		; loop down pixel rows

		jmp	Lexit

; routine for all other bit blocks

L15:		not	ch		; CH := mask for end of row
		mov	dx,0FF00h
		ror	dx,cl		; DX := rotated mask for each byte

		mov	bx,VARPixelRowLen
		dec	bx		; BX := bytes per row - 1

L16:		push	di
		test	bx,bx
		jz	L18		; jump if only one byte per row

		push	bx

L17:		and	es:[di],dx	; mask next 8 pixels in video buffer
		lodsb			; AL := pixels in bit block
		xor	ah,ah
		ror	ax,cl		; AX := pixels rotated into position
		or	es:[di],ax	; set pixels in video buffer
		inc	di		; ES:DI -> next byte in bit block
		dec	bx
		jnz	L17

		pop	bx

L18:		mov	al,ch
		mov	ah,0FFh		; AX := mask for last pixels in row
		ror	ax,cl		; AX := mask rotated into position
		and	es:[di],ax	; mask last pixels in video buffer
		lodsb			; AL := last byte in row
		xor	ah,ah
		ror	ax,cl		; AX := pixels rotated into position
		or	es:[di],ax	; set pixels in video buffer

		pop	di
		add	di,VARincr	; ES:DI -> next pixel row in buffer
		xor	VARincr,2000h XOR (80-2000h)
		dec	VARPixelRows
		jnz	L16		; loop down pixel rows

		jmp	Lexit


XORBitBlock:
		mov	bx,VARPixelRowLen

L20:		push	di
		push	bx

L21:		lodsb			; AL := pixels in bit block
		xor	ah,ah
		ror	ax,cl		; AX := pixels rotated into position
		xor	es:[di],ax	; XOR pixels into video buffer
		inc	di		; ES:DI -> next byte in bit block
		dec	bx
		jnz	L21

		pop	bx
		pop	di
		add	di,VARincr	; ES:DI -> next pixel row in buffer
		xor	VARincr,2000h XOR (80-2000h)
		dec	VARPixelRows
		jnz	L20		; loop down pixel rows

		jmp	Lexit

ANDBitBlock:
		not	ch		; CH := mask for end of row

		mov	bx,VARPixelRowLen
		dec	bx		; BX := bytes per row - 1

L30:		push	di
		test	bx,bx
		jz	L32		; jump if only one byte per row

		push	bx

L31:		lodsb			; AL := pixels in bit block
		mov	ah,0FFh
		ror	ax,cl		; AX := pixels rotated into position
		and	es:[di],ax	; AND pixels into video buffer
		inc	di		; ES:DI -> next byte in bit block
		dec	bx
		jnz	L31

		pop	bx

L32:		lodsb			; AL := last byte in row
		or	al,ch		; mask last pixels in row
		mov	ah,0FFh
		ror	ax,cl		; AX := pixels rotated into position
		and	es:[di],ax	; AND pixels into video buffer

		pop	di
		add	di,VARincr	; ES:DI -> next pixel row in buffer
		xor	VARincr,2000h XOR (80-2000h)
		dec	VARPixelRows
		jnz	L30		; loop down pixel rows

		jmp	Lexit


ORBitBlock:
		mov	bx,VARPixelRowLen

L40:		push	di
		push	bx

L41:		lodsb			; AL := pixels in bit block
		xor	ah,ah
		ror	ax,cl		; AX := pixels rotated into position
		or	es:[di],ax	; OR pixels into video buffer
		inc	di		; ES:DI -> next byte in bit block
		dec	bx
		jnz	L41

		pop	bx
		pop	di
		add	di,VARincr	; ES:DI -> next pixel row in buffer
		xor	VARincr,2000h XOR (80-2000h)
		dec	VARPixelRows
		jnz	L40		; loop down pixel rows


Lexit:		pop	di		; restore registers and exit
		pop	si
		pop	ds
		mov	sp,bp
		pop	bp
		ret

_StoreBitBlock06 ENDP

_TEXT		ENDS


_DATA		SEGMENT	word public 'DATA'

StoreBitBlockOp	DW	ReplaceBitBlock	; address of selected subroutine
					;  (Replace, XOR, AND, OR)

_DATA		ENDS

		END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     In the MCGA's 640-by-480 2-color and 320-by-200 256-color modes, pixel
     addressing is different than in the two CGA-compatible modes.
     Otherwise, versions of GetBitBlock() and StoreBitBlock() are similar
     in all MCGA modes.


EGA and VGA

     In native EGA and VGA graphics modes, the bit block move routine must
     move the contents of all four bit planes to system RAM. The
     GetBitBlock() routine in Listing 11-3 extracts bytes from each
     bit plane using read mode 0 and selecting each bit plane in turn with
     the Graphics Controller's Read Map Mask register. StoreBitBlock(), in
     Listing 11-4, then uses write mode 0 to copy data into the bit
     planes. The bit planes are isolated in write mode 0 by programming the
     Sequencer's Map Mask register.

     Do not use the routines in Listings 11-3 and 11-4 on an EGA with
     only 64 KB of video RAM. Because the memory maps are chained together
     to form the two bit planes used in 640-by-350 graphics modes, these
     routines will not work properly in this situation. (Chapter 4
     discusses this in greater detail.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-3.  A routine to copy a block of pixels from the EGA or VGA
     video buffer to system RAM in native graphics modes.

		TITLE	'Listing 11-3'
		NAME	GetBitBlock10
		PAGE	55,132

;
; Name:		GetBitBlock10
;
; Function:	Copy bit block from video buffer to system RAM
;		 in native EGA and VGA graphics modes
;
; Caller:	Microsoft C:
;
;			int GetBitBlock10(x0,y0,x1,y1,buf);
;
;			     int x0,y0;    /* upper left corner of bit block */
;			     int x1,y1;       /* lower right corner */
;			     char far *buf;   /* buffer */
;
; Notes:	Returns size of bit block in system RAM.
;


ARGx0		EQU	word ptr [bp+4]
ARGy0		EQU	word ptr [bp+6]
ARGx1		EQU	word ptr [bp+8]
ARGy1		EQU	word ptr [bp+10]
ADDRbuf		EQU	         [bp+12]

VARPixelRows	EQU	word ptr [bp-2]
VARPixelRowLen	EQU	word ptr [bp-4]

BytesPerRow	EQU	80
ByteOffsetShift	EQU	3		; reflects number of pixels per byte


_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT

		EXTRN	PixelAddr10:near

		PUBLIC	_GetBitBlock10
_GetBitBlock10	PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		sub	sp,4		; establish stack frame
		push	ds
		push	si
		push	di

; compute dimensions of bit block

		mov	ax,ARGx1
		sub	ax,ARGx0
		mov	cx,0FF07h	; CH := unshifted bit mask
					; CL := AND mask for AL
		and	cl,al		; CL := number of pixels in last
					;  byte of row
		xor	cl,7		; CL := number of bits to shift
		shl	ch,cl		; CH := bit mask for last byte of row
		mov	cl,ch
		push	cx		; save on stack

		mov	cl,ByteOffsetShift
		shr	ax,cl
		inc	ax		; AX := number of bytes per row
		push	ax		; save on stack

		mov	ax,ARGy1
		sub	ax,ARGy0
		inc	ax		; AX := number of pixel rows
		push	ax		; save on stack

; establish addressing

		mov	ax,ARGy0
		mov	bx,ARGx0
		call	PixelAddr10	; ES:BX -> x0,y0 in video buffer
		xor	cl,7		; CL := number of bits to shift left
		push	es
		pop	ds
		mov	si,bx		; DS:SI -> video buffer

		les	di,ADDRbuf	; ES:DI -> buffer in system RAM

; build 5-byte bit block header

		pop	ax
		mov	VARPixelRows,ax
		stosw			; byte 0-1 := number of pixel rows
		pop	ax
		mov	VARPixelRowLen,ax
		stosw			; byte 2-3 := bytes per pixel row
		pop	ax
		mov	ch,al		; CH := bit mask for last byte in row
		stosb			; byte 4 := bit mask for last byte

; set up Graphics Controller

		mov	dx,3CEh		; DX := Graphics Controller address port

		mov	ax,0005		; AH := 0 (read mode 0, write mode 0)
					; AL := 5 (Mode register number)
		out	dx,ax		; set up read mode 0
 
		mov	ax,0304h	; AH := 3 (first bit plane to read)
					; AL := 4 (Read Map Select reg number)

; copy from video buffer to system RAM

L01:		out	dx,ax		; select next memory map to read
		push	ax		; preserve memory map number
		push	VARPixelRows	; preserve number of pixel rows
		push	si		; preserve offset of x0,y0

L02:		mov	bx,VARPixelRowLen
		push	si		; preserve SI at start of pixel row

L03:		lodsw			; AL := next byte in video buffer
					; AH := (next byte) + 1
		dec	si		; DS:SI -> (next byte) + 1
		rol	ax,cl		; AL := next 4 pixels in row
		stosb			; copy to system RAM
		dec	bx		; loop across row
		jnz	L03

		and	es:[di-1],ch	; mask last byte in row
		pop	si		; DS:SI -> start of row
		add	si,BytesPerRow	; DS:SI -> start of next row

		dec	VARPixelRows
		jnz	L02		; loop down rows

		pop	si		; DS:SI -> start of bit block
		pop	VARPixelRows	; restore number of pixel rows
		pop	ax		; AH := last map read
					; AL := Read Map Select reg number
		dec	ah
		jns	L01		; loop across bit planes

		mov	ax,di
		sub	ax,ADDRbuf	; AX := return value (size of bit block
					;  in system RAM)

		pop	di		; restore registers and exit
		pop	si
		pop	ds
		mov	sp,bp
		pop	bp
		ret

_GetBitBlock10	ENDP

_TEXT		ENDS

		END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-4.  A routine to copy a block of pixels from system RAM
     to the EGA or VGA video buffer in native graphics mode.

		TITLE	'Listing 11-4'
		NAME	StoreBitBlock10
		PAGE	55,132

;
; Name:		StoreBitBlock10
;
; Function:	Copy bit block from video buffer to system RAM
;		 in native EGA and VGA graphics modes
;
; Caller:	Microsoft C:
;
;			void StoreBitBlock10(buf,x,y);
;
;			     char far *buf;   /* buffer */
;			     int x,y;    /* upper left corner of bit block */
;


ADDRbuf		EQU	dword ptr [bp+4]
ARGx		EQU	word ptr [bp+8]
ARGy		EQU	word ptr [bp+10]

VARPixelRows	EQU	word ptr [bp-2]
VARPixelRowLen	EQU	word ptr [bp-4]
VARRowCounter	EQU	word ptr [bp-6]
VARStartMask	EQU	word ptr [bp-8]
VAREndMaskL	EQU	word ptr [bp-10]
VAREndMaskR	EQU	word ptr [bp-12]

BytesPerRow	EQU	80		; logical width of video buffer
ByteOffsetShift	EQU	3		; reflects number of pixels per byte
RMWbits		EQU	18h		; selects replace, XOR, AND, or OR

_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT

		EXTRN	PixelAddr10:near

		PUBLIC	_StoreBitBlock10
_StoreBitBlock10	PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		sub	sp,12		; establish stack frame
		push	ds
		push	si
		push	di

; establish addressing

		mov	ax,ARGy
		mov	bx,ARGx
		call	PixelAddr10	; ES:BX -> byte offset of x,y
		inc	cl
		and	cl,7		; CL := number of bits to shift left

		mov	di,bx		; ES:DI -> x,y in video buffer
		
		lds	si,ADDRbuf	; ES:DI -> buffer in system RAM

; obtain dimensions of bit block from header

		lodsw			; AX := number of pixel rows
		mov	VARPixelRows,ax
		lodsw			; AX := bytes per pixel row
		mov	VARPixelRowLen,ax
		lodsb			; AL := bit mask for last byte in row
		mov	ch,al

; set up Graphics Controller

		mov	dx,3CEh		; DX := Graphics Controller I/O port

		mov	ah,RMWbits	; AH := value for Data Rotate/Function
		mov	al,3		;  Select register
		out	dx,ax		; update this register

		mov	ax,0805h	; AH := 8 (read mode 1, write mode 0)
					; AL := 5 (Mode register number)
		out	dx,ax		; set up read mode 0

		mov	ax,0007		; AH := 0 (don't care for all maps;
					;  CPU reads always return 0FFH)
					; AL := 7 (Color Don't Care reg number)
		out	dx,ax		; set up Color Don't Care reg

		mov	ax,0FF08h	; AH := 0FFH (value for Bit Mask reg)
		out	dx,ax		; set up Bit Mask reg

		mov	dl,0C4h		; DX := 3C4H (Sequencer I/O port)
		mov	ax,0802h	; AH := 1000B (value for Map Mask reg)
					; AL := 2 (Map Mask register number)

		cmp	cx,0FF00h	; if mask <> 0FFH or bits to shift <> 0
		jne	L15		;  jump if not byte-aligned

; routine for byte-aligned bit blocks

		mov	cx,VARPixelRowLen

L10:		out	dx,ax		; enable one bit plane for writes
		push	ax		; preserve Map Mask value
		push	di		; preserve video buffer offset of x,y
		mov	bx,VARPixelRows

L11:		push	di		; preserve DI and CX
		push	cx

L12:		lodsb			; AL := next byte of pixels
		and	es:[di],al	; update bit plane
		inc	di
		loop	L12
		
		pop	cx		; restore DI and CX
		pop	di	
		add	di,BytesPerRow	; ES:DI -> next pixel row in buffer
		dec	bx
		jnz	L11		; loop down pixel rows

		pop	di		; ES:DI -> video buffer offset of x,y
		pop	ax		; AH := current Map Mask reg value
		shr	ah,1		; AH := new Map Mask value
		jnz	L10		; loop across all bit planes

		jmp	Lexit

; routine for non-aligned bit blocks

L15:		push	ax		; preserve Map Mask reg values

		mov	bx,0FFh		; BH := 0 (mask for first byte in row)
					; BL := 0FFh
		mov	al,ch		; AL := mask for last byte in pixel row
		cbw			; AH := 0FFh (mask for last-1 byte)

		cmp	VARPixelRowLen,1
		jne	L16		; jump if more than one byte per row

		mov	bl,ch
		mov	ah,ch		; AH := mask for last-1 byte
		xor	al,al		; AL := 0 (mask for last byte)

L16:		shl	ax,cl		; shift masks into position
		shl	bx,cl

		mov	bl,al		; save masks along with ..
		mov	al,8		; .. Bit Mask register number
		mov	VAREndMaskL,ax
		mov	ah,bl
		mov	VAREndMaskR,ax
		mov	ah,bh		
		mov	VARStartMask,ax
		
		mov	bx,VARPixelRowLen
		pop	ax		; restore Map Mask reg values

; set pixels row by row in the bit planes

L17:		out	dx,ax		; enable one bit plane for writes
		push	ax		; preserve Map Mask value
		push	di		; preserve video buffer offset of x,y
		mov	dl,0CEh		; DX := 3CEH (Graphics Controller port)

		mov	ax,VARPixelRows
		mov	VARRowCounter,ax  ; initialize loop counter

; set pixels at start of row in currently enabled bit plane

L18:		push	di		; preserve offset of start of pixel row
		push	si		; preserve offset of row in bit block 
		push	bx		; preserve bytes per pixel row

		mov	ax,VARStartMask
		out	dx,ax		; set Bit Mask reg for first byte of row

		lodsw			; AH := 2nd byte of pixels
					; AL := 1st byte of pixels
		dec	si		; DS:SI -> 2nd byte of pixels
		test	cl,cl
		jnz	L19		; jump if not left-aligned

		dec	bx		; BX := bytes per row - 1
		jnz	L20		; jump if at least 2 bytes per row
		jmp	short L22	; jump if only one byte per row

L19:		rol	ax,cl		; AH := left part of 1st byte,
					;	 right part of 2nd byte
					; AL := right part of 1st byte,
					;	 left part of 2nd byte
		and	es:[di],ah	; set pixels for left part of first byte
		inc	di
		dec	bx		; BX := bytes per row - 2

L20:		push	ax		; preserve pixels
		mov	ax,0FF08h
		out	dx,ax		; set Bit Mask reg for succeeding bytes
		pop	ax

		dec	bx
		jng	L22		; jump if only 1 or 2 bytes in pixel row

; set pixels in middle of row

L21:		and	es:[di],al	; set pixels in right part of current
		inc	di		;  byte and left part of next byte

		lodsw			; AH := next+1 byte of pixels
		dec	si		; AL := next byte of pixels
		rol	ax,cl		; AH := left part of next byte, right
					;	 part of next+1 byte
					; AL := right part of next byte, left
					;	 part of next+1 byte
		dec	bx
		jnz	L21		; loop across pixel row

; set pixels at end of row

L22:		mov	bx,ax		; BH := right part of last byte, left
					;	 part of last-1 byte
					; BL := left part of last byte, right
					;	 part of last-1 byte
		mov	ax,VAREndMaskL	; AH := mask for last-1 byte
					; AL := Bit Mask reg number
		out	dx,ax		; set Bit Mask register
		and	es:[di],bl	; set pixels for last-1 byte

		mov	ax,VAREndMaskR	; mask for last byte in pixel row
		out	dx,ax		; .. last byte in pixel row
		and	es:[di+1],bh	; set pixels for last byte

		pop	bx		; BX := bytes per pixel row
		pop	si
		add	si,bx		; DS:SI -> next row in bit block
		pop	di
		add	di,BytesPerRow	; ES:DI -> next pixel row in buffer
		dec	VARRowCounter
		jnz	L18		; loop down pixel rows

		pop	di		; ES:DI -> video buffer offset of x,y
		pop	ax		; AX := current Map Mask value
		mov	dl,0C4h		; DX := 3C4H
		shr	ah,1		; AH := next Map Mask value
		jnz	L17		; loop across bit planes

; restore Graphics Controller and Sequencer to their default states

Lexit:		mov	ax,0F02h	; default Map Mask value
		out	dx,ax

		mov	dl,0CEh		; DX := 3CEh
		mov	ax,0003		; default Data Rotate/Function Select
		out	dx,ax

		mov	ax,0005		; default Mode value
		out	dx,ax

		mov	ax,0F07h	; default Color Compare value
		out	dx,ax

		mov	ax,0FF08h	; default Bit Mask value
		out	dx,ax

		pop	di		; restore registers and exit
		pop	si
		pop	ds
		mov	sp,bp
		pop	bp
		ret

_StoreBitBlock10 ENDP

_TEXT		ENDS

		END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


HGC

     Bit block move routines for HGC and HGC+ 720-by-348 monochrome
     graphics mode are similar routines for CGA 640-by-200 2-color mode.
     The differences  are in how they calculate pixel addresses and in the
     way the video buffer is interleaved.


InColor Card

     The routines for the InColor Card's 720-by-348 16-color mode resemble
     the EGA routines in Listings 11-3 and 11-4, because both adapters'
     video buffers are mapped in parallel bit planes. Differences between
     the routines lie in the way pixel addresses are computed, in how the
     video buffer is interleaved, and in how individual bit planes are
     accessed. On the InColor Card, you can use the same technique as
     ReadPixelInC() (discussed in Chapter 5) to program the Read/Write
     Control and Color registers and isolate the contents of each bit
     plane. Similarly, a bit block store routine for the InColor Card
     follows  StorePixelInC() in its use of the Plane Mask register and the
     Read/Write Control and Color registers.


Bitwise Pixel Operations


     If you experimented with the pixel-programming and line-drawing
     examples in previous chapters, you probably know why the bitwise
     logical operations--XOR, AND, and OR--are useful in video graphics
     programming. In this case, you can skip the next few paragraphs.
     Otherwise, read on to see how video graphics programs can exploit the
     ability to perform XOR, AND, and OR on pixel values.


XOR


     The XOR operation is useful because it is reversible. When you change
     a pixel's value in the video buffer using the XOR function, you can
     restore its original value by repeating the operation. For example, if
     a pixel in the video buffer has the value 9, setting its value by
     XORing it with a value of 5 results in a pixel value of 0CH. XORing
     the resulting pixel value (0CH) with a value of 5 restores the
     original pixel value of 9.

     This implies that you can XOR objects into the video buffer and onto
     the screen, and then erase them, without worrying about saving and
     restoring the contents of the video buffer. The use of XOR has
     limitations, however. One is that an image containing zero-value
     pixels cannot be XORed into the video buffer. Because XORing a pixel
     with 0 leaves the pixel's value unchanged, only nonzero pixels in the
     image affect the video buffer.

     Another more serious limitation is that a patterned background can
     obscure the image you are trying to XOR into the video buffer.
     Consider Figure 11-1, in which a text string is XORed against
     progressively distracting backgrounds. The text is perfectly readable
     against a solid background, but a striped background significantly
     obscures the letters. In the worst case, XORing a single-color image
     into a pattern of random pixels results only in another pattern of
     random pixels.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-1 is found on page 361      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-1.  Effects of XORing a text string against various
     backgrounds.


NOT

     A bitwise NOT operation on a pixel value toggles all 1 bits to 0 and
     all 0 bits to 1. Obviously, two sequential NOT operations will leave
     the pixel value unchanged. A common programming practice in monochrome
     graphics modes is to use NOT to toggle a reverse video state. For
     instance, a black-on-white character can be reversed to white-on-black
     by performing NOT operations on its pixels.

     The effect of NOT on multibit pixel values is less clear. In this
     situation, the NOT operation converts one pixel value into some other
     pixel value, but the colors corresponding to these two values may be
     unrelated. Thus, in a color graphics mode, performing a NOT operation
     on all pixels in a character matrix changes both the foreground and
     background values, but the resulting color combination may not be
     particularly attractive or even readable. In manipulating pixels in
     color graphics, use NOT with caution.

       ÉÍÍÍ»     A bitwise NOT is equivalent to performing a bitwise XOR
       º T º     using a binary value of all 1 bits. This means you can use
       º I º     any of the pixel XOR routines developed in this book to
       º P º     perform NOT operations as well. Thus, little can be gained
       ÈÍÍÍ¼     by writing special-purpose NOT routines for pixel
                 manipulation.


AND

     The bitwise logical operation AND is also useful in manipulating
     graphics images. Consider, for instance, how you might go about
     drawing the striped circle in Figure 11-2b. You could do it the hard
     way, by intersecting a set of parallel lines with the circle. This
     procedure would be laborious, however, because of the extra
     programming and increased computational overhead involved in
     determining the intersection points.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-2 is found on page 362      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-2.  Using AND to draw a striped circle. The circle in Figure
     11-2a consists of pixels of the maximum possible value. The lines are
     drawn across the circle using a pixel AND operation to produce the
     striped circle in Figure 11-2b.


     It is much easier to draw a filled circle (see Figure 11-2a) with
     pixels of the maximum possible value (that is, all bits set to 1)
     against a background of zero-value pixels. This circle is used as a
     mask against which you AND the pixels in the parallel lines. When
     pixels in each line are ANDed with pixels inside the circle, their
     original values are stored intact in the video buffer. Outside the
     circle, the result of ANDing the line pixels with the zero background
     always results in zero-value pixels being stored in the buffer. The
     result: a striped circle.

     You can apply this technique to any graphics form, but it is
     particularly attractive in conjunction with a bit block move routine.
     You can superimpose patterned images with a short sequence of bit
     block moves using pixel AND and OR operations. In Figure 11-3, a
     circular chunk of pattern B is superimposed on pattern A by using a
     mask to isolate a "hole" in pattern A. The inverse of the same mask
     extracts the congruent piece of pattern B. The two masked patterns are
     then superimposed by a third bit block move that uses OR (or XOR) to
     update pixels.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-3 is found on page 362      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-3.  Masking patterned images with pixel AND operations.


OR

     The bitwise OR operator is less frequently used than XOR for
     manipulating pixel values. The OR operation, unlike XOR or NOT, is not
     reversible. The result of ORing pixels always depends on their
     previous values in the video buffer.

     One typical use of the pixel OR operation is to accentuate
     intersections of forms in the video buffer. Consider what happens when
     you OR two different-colored areas into a 16-color video buffer (see
     Figure 11-4). If one rectangle is filled with pixels of value 3 and
     the other rectangle with pixels of value 5, the pixels at the
     intersection points have the value 7 (3 OR 5). With the usual default
     color palette, the upper rectangle appears cyan, the lower rectangle
     is violet, and the intersection is white.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿          
     ³°°°°°°°°°°°°°°°°°°°°³          
     ³°Cyan°°°°°°°°°°°°°°°³          
     ³°°°°°°°°°°°°°°°°°°°°³          
     ³°°°°°°°°°°ÚÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ¿
     ³°°°°°°°°°°³         ³±±±±±±±±±³
     ³°°°°°°°°°°³ White   ³±±±±±±±±±³
     ³°°°°°°°°°°³         ³±±±±±±±±±³
     ÀÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÙ±±±±±±±±±³
                ³±±±±±±±±±±±±±±±±±±±³
                ³±±±±±±±±±±±±Violet±³
                ³±±±±±±±±±±±±±±±±±±±³
                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 11-4.  ORing two colored areas into a 16-bit video buffer.


Bit Block Tiling


     You can use bit block move routines to fill an area of the video
     buffer with any arbitrary pattern. Do this by tiling the buffer
     through bit block moves to adjoining rectangular areas of the buffer
     (see Figure 11-5). Using the AND mask technique, you can fill any
     arbitrary form, such as the circle in Figure 11-6, with a pattern
     contained in a bit block.



             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-5 is found on page 363      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-5.  Bit block tiling.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-6 is found on page 364      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-6.  Tiling with AND mask.


       ÉÍÍÍ»     You can use a variation of bit block tiling as a sort of
       º T º     software character generator. If you define a group of bit
       º I º     blocks, each of which represents a character in a

       º P º     character set, you can tile the screen with characters.
       ÈÍÍÍ¼     This is one technique for displaying proportionally
                 spaced characters.


Animation


     PC and PS/2 video subsystems have no built-in hardware to support
     animation. Consequently, moving images across the screen is a task
     relegated to software. (This is a good reason to make your video
     graphics routines as efficient as possible.) Several software
     techniques can produce real-time video animation. Each technique is
     best suited to a particular type of animation.


XOR Animation

     You can take advantage of the reversibility of the logical XOR
     operation to make any pixel or set of pixels appear to move across the
     display. To make an object appear to move, XOR it into the video
     buffer twice. The object flickers onto the screen the first time it is
     drawn. It immediately disappears the second time it is drawn. If you
     repeatedly redraw the object in a slightly different position, it
     appears to move across the screen.

     Outlining
     Consider the C fragment in Listing 11-5. This bit of code makes a
     circle appear to grow outward from its center by repeatedly XORing it
     into the video buffer with a gradually increasing radius.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-5.  XORing a circle into the video buffer.

/* Listing 11-5 */

main()
{
	int	xc	= 400;		/* center of circle */
	int	yc	= 125;
	int	a,b;			/* semimajor and semiminor axes */
	int	n = 12;			/* pixel value */
	int	i;
	float	ScaleFactor = 1.37;	/* for 640x350 16-color mode */


	for( i=0; i<10; i++ )
	  for( a=0; a<100; a++ )
	  {
	    b = (float) a / ScaleFactor;	/* scale semiminor axis */
	    Ellipse10( xc, yc, a, b, n );	/* draw a circle */
	    Ellipse10( xc, yc, a, b, n );	/* draw it again */
	  }
}


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     This technique is frequently used interactively to outline a
     rectangular area of the display. The outline is rapidly XORed into and
     out of the video buffer as the user moves a pointing device such as a
     mouse. Just as the circle created by the routine in Listing 11-5
     appears to grow, a rectangular outline can appear to move, grow, or
     shrink in response to the user's actions.

     The routine in Listing 11-6 slides a rectangle across the screen. At
     each iteration, the rectangle is drawn and then erased using lines
     that are XORed into the video buffer. In this example, the rectangle's
     onscreen location is changed within an iterative loop. In practice,
     however, the rectangle's size and location could be changed in
     response to input from the keyboard or from a pointing device. In this
     case, the rectangle would be erased and redrawn whenever the input
     indicated a change in position.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-6.  XORing a rectangle into the video buffer.

/* Listing 11-6 */

#define	Xmax	640

#define	TRUE	1
#define	FALSE	0

main()
{
	int	x0	= 0;		/* corners of box at 0,0 and 150,100 */
	int	y0	= 0;
	int	x1	= 150;
	int	y1	= 100;
	int	n = 12;			/* pixel value */


	while( x1 < Xmax )			/* slide box right */
	  XORBox( x0++, y0, x1++, y1, n );

	while( x0 > 0 )				/* slide box left */
	  XORBox( --x0, y0, --x1, y1, n );
}


XORBox ( x0, y0, x1, y1, n )
int	x0,y0,x1,y1;		/* pixel coordinates of opposite corners */
int	n;			/* pixel value */
{
	Rectangle( x0, y0, x1, y1, n );			     /* draw the box */
	Rectangle( x0, y0, x1, y1, n );			    /* erase the box */
}


Rectangle( x0, y0, x1, y1, n )
int	x0,y0,x1,y1;
int	n;
{
	Line10( x0, y0, x0, y1, n );
	Line10( x0, y0, x1, y0, n );
	Line10( x1, y1, x0, y1, n );
	Line10( x1, y1, x1, y0, n );
}


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Rubberbanding
     A related technique based on the XOR operation is rubberbanding, in
     which a moving object remains attached to a stationary object by a
     straight line. The technique is called rubberbanding because the line
     that connects the two objects appears to stretch as it moves. Listing
     11-7 is similar to Listing 11-6, but moves a rubberbanded line around
     the point at (150,100).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-7.  XORing a line into the video buffer.

/* Listing 11-7 */

#define	Xmax	640			/* screen dimensions in 640x350 mode */
#define	Ymax	350

main()
{
	int	x0	= 150;		/* fixed endpoint at 150,100 */
	int	y0	= 100;
	int	x	= 0;		/* moving endpoint at 0,0 */
	int	y	= 0;
	int	n	= 12;		/* pixel value */


	for( ; x<Xmax; x++ )			/* move right */
	  XORLine( x0, y0, x, y, n );

	for( --x; y<Ymax; y++ )			/* move down */
	  XORLine( x0, y0, x, y, n );

	for( --y; x>=0; --x )			/* move left */
	  XORLine( x0, y0, x, y, n );

	for( x++; y>=0; --y )			/* move up */
	  XORLine( x0, y0, x, y, n );
}


XORLine ( x0, y0, x1, y1, n )
int	x0,y0,x1,y1;		/* endpoints */
int	n;			/* pixel value */
{
	Line10( x0, y0, x1, y1, n );		     /* the line is onscreen */
	Line10( x0, y0, x1, y1, n );		       /* the line is erased */
}


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Bit Block Moves
     You can use XOR with a bit block move to animate any arbitrary group
     of pixels. But use this technique only with a relatively small bit
     block, since generally a bit block contains many more pixels to be
     drawn and redrawn than does a line or a rectangle. The longer it takes
     to maneuver the bit block around the screen, the slower your video
     routine performs.


     Problems with XOR Animation
     Objects that are animated by XOR operations always flicker. The reason
     is obvious: An object is visible only after you first XOR it into the
     buffer. The second XOR makes it disappear. The resulting flicker draws
     attention to the animated object, and may be desirable, particularly
     if the object is repeatedly XORed even when you aren't moving it. On
     the other hand, the flickering can be distracting, particularly on
     color displays where the XORed object alternates between two garish
     colors.

     You can sometimes alleviate flickering during XOR animation by
     inserting a software "pause" between the first and second XOR
     operations. This pause can be an empty loop, a call to some short
     subroutine, or perhaps a wait for the next vertical blanking interval.
     In any case, because the XORed object remains on the screen slightly
     longer, it may flicker less.

     The animated image can disappear if the loop that performs the XOR
     operations inadvertently becomes synchronized with the display refresh
     cycle. In this situation, the animated object is never visible if both
     XOR operations occur outside the relatively brief time interval when
     the raster is displaying the relevant portion of the video buffer.
     Solving this sort of problem is tricky because it involves both the
     speed of your program and the size of the animated image.


Overlapping Bit Block Moves

     In some applications, you can avoid XOR animation problems by rapidly
     redrawing a block of pixels in overlapping locations in the video
     buffer (see Figure 11-7 and Listing 11-8). The bit block in Figure
     11-7 has a margin of background pixels along its left edge. Each time
     you store the bit block in the video buffer, this margin overlaps the
     foreground pixels in the previously drawn block. Without this margin,
     unexpected streaks of foreground pixels trail the bit block as it
     moves to the right across the screen.

     Although they are fast enough for most purposes, the bit block move
     routines in this chapter are too slow for such performance-intensive
     applications as arcade-style video games. You can tailor the code in
     several ways to increase the animation speed if you're willing to
     sacrifice their general-purpose approach.


     ÚÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿        ÚÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ¿
     ³°°³                  ³        ³°°³°°³            |  ³
     |°°³                  ³        |°°³°°³            |  ³
     ³°°³                  ³        ³°°³°°³            |  ³
     |°°³                  ³        |°°³°°³            |  ³
     ³°°³                  ÃÄÄÄÄÄÄÄ³°°³°°³            |  ³
     |°°³                  ³        |°°³°°³            |  ³
     ³°°³                  ³        ³°°³°°³            |  ³
     |°°³                  ³        |°°³°°³            |  ³
     ÀÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ        ÀÄÄÁÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÙ
                                      
      ³                              ³  ³ Margin
      ³ Margin of                    ³
      ³ background pixels            ³ Previous margin
    a.            b.

     Figure 11-7.  Overlapping bit block moves. The bit block is drawn
     (Figure 11-7a), then drawn again slightly to the right (Figure
     11-7b). The margin of background pixels restores the background as
     the bit block is "moved" to the right.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-8.  A program to move a block of pixels using the
     overlapping technique.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     One technique is to limit the bit block routines to byte-aligned (or,
     on the CGA and the HGC, word-aligned) blocks of pixels. This
     eliminates much of the bit-mask logic and lets you make full use of
     the 80x86 MOVs instruction. Another approach is to write routines that
     handle bit blocks of a fixed, predetermined size. This lets you
     replace some iterative loops in the routines with repetitive sequences
     of in-line code. Unfortunately, even highly optimized CGA and EGA
     animation routines rarely come close to the speed you can expect from
     arcade-style video display hardware.


A Graphics-Mode Cursor


     In alphanumeric modes, the on-screen cursor indicates the location
     where your program expects the user's next input. Most alphanumeric-
     mode programs rely on the hardware-generated blinking cursor to
     indicate the current input location. In graphics modes, on the other
     hand, hardware does not support a cursor; your software must generate
     one.

     Implementing a cursor in a graphics mode is somewhat complicated,
     because you must draw the form that represents the cursor directly
     into the video buffer, while preserving the pixels that the operation
     overwrites. You can do this in two ways: by using XOR to display the
     cursor, or by saving and restoring the bit block that is overlaid by
     the cursor.


XOR

     The simplest way to display a graphics cursor is to XOR it into and
     then out of the video buffer. This technique is the same one used to
     animate graphics images, and the same pros and cons apply.

     Probably the worst side effect of XORing a graphics cursor into the
     video buffer is that the color displayed for the XORed cursor can
     change with the background. The cursor can all but disappear on a
     patterned background or on a background with a displayed color near
     that of the XORed cursor.

     Palette programming can prevent this problem. For example, the EGA
     palette in Figure 11-8 is set up assuming that all pixels in the
     cursor shape have the value 8 (1000B) and that all preexisting pixels
     in the video buffer have a value from 0 through 7. With this
     arrangement, XORing the cursor into the video buffer causes it always
     to be displayed with color value 3FH (high-intensity white). The
     obvious drawback is that this technique halves the number of colors
     you can display.


Palette Register   Color Value
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H                0
01H                1
02H                2
03H                3
04H                4
05H                5
06H                6
07H                7
08H                3FH
09H                3FH
0AH                3FH
0BH                3FH
0CH                3FH
0DH                3FH
0EH                3FH
0FH                3FH
     Figure 11-8.  EGA palette values for a high-intensity white XOR
     graphics cursor.


Bit Block Move

     Another approach is to make a copy of the bit block of pixels that the
     cursor replaces. You can then erase the cursor by restoring the pixels
     in the video buffer from the copy. This technique is attractive
     because it lets you use any means you choose to draw the cursor.

     A good way to draw the cursor, once you have made a copy of the
     underlying pixels in the video buffer, is to copy the cursor shape
     into the buffer with a bit block move. Obviously, this technique works
     best with a rectangular cursor. To draw a cursor of any arbitrary
     shape, use a two-step process (see Figure 11-9). First, zero a group
     of pixels in the shape of the cursor in the video buffer with a bit
     block AND operation. Then draw the cursor with a bit block OR or XOR
     operation.

       ÉÍÍÍ»     Whenever you use a graphics-mode cursor, you must ensure
       º T º     that the cursor is erased before updating the video
       º I º     buffer. If you do not, your program may inadvertently
       º P º     update the portion of the video buffer that contains the
       ÈÍÍÍ¼     cursor image. The next cursor move will restore the
                 contents of the buffer to what they were before the cursor
                 was drawn, leaving a "hole" where the cursor was (see
                 Figure 11-10).


     ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛ     ÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛ     ÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛ     ÛÛÛÛÛ           ÛÛÛ           ÛÛÛÛÛÛÛÛÛÛÛ ÛÛÛ ÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛ         ÛÛÛ           ÛÛÛ           ÛÛÛÛÛÛÛÛÛ   ÛÛÛ   ÛÛÛÛÛÛÛÛÛ
     ÛÛÛ         ÛÛÛ         ÛÛÛÛÛÛÛ         ÛÛÛÛÛÛÛÛÛ ÛÛÛÛÛÛÛ ÛÛÛÛÛÛÛÛÛ
     ÛÛÛ         ÛÛÛ         ÛÛÛÛÛÛÛ         ÛÛÛÛÛÛÛÛÛ ÛÛÛÛÛÛÛ ÛÛÛÛÛÛÛÛÛ
     ÛÛÛ         ÛÛÛ           ÛÛÛ           ÛÛÛÛÛÛÛÛÛ   ÛÛÛ   ÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛ     ÛÛÛÛÛ           ÛÛÛ           ÛÛÛÛÛÛÛÛÛÛÛ ÛÛÛ ÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛ     ÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛ     ÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
     a.                    b.                c.

     Figure 11-9.  Drawing a graphics cursor with a 2-step mask-and-replace
     technique: First, a mask (Figure 11-9a) is ANDed into the video
     buffer. Then the cursor shape (Figure 11-9b) is ORed into the buffer
     to give the result in Figure 11-9c.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-10 is found on page 371     º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-10.  If a graphics cursor is accidentally overwritten
     (Figure 11-10a), a "hole" appears when the cursor is erased (Figure
     11-10b).

