

                         9  Graphics Text


                     Character Definition Tables
                         Video BIOS Support
                Creating a Character Definition Table

                    Software Character Generators
                 Video BIOS Support þ Pixel Handling

              Designing a Software Character Generator
                        Horizontal Alignment
                 Variable Character Sizes þ Clipping
                        Character Orientation
                   Cooperating with the Video BIOS
                     More Power, More Complexity

             Implementing a Software Character Generator
                      CGA þ HGC and HCG+ þ MCGA
                     EGA and VGA þ InColor Card



     Few programs are complete without some sort of text display. Most
     graphics applications incorporate text with graphics images. In
     graphics modes, the software that draws characters requires the same
     thoughtful design and construction as do routines that draw geometric
     figures such as lines and ellipses.

     In alphanumeric video modes, of course, displaying text is easy. You
     simply place a character code and attribute in the video buffer and
     let the hardware character generator put pixels on the screen. In
     graphics modes, however, your program must store every pixel of every
     character in the video buffer.

     This chapter discusses how to translate character codes into the pixel
     patterns that form characters in graphics modes. The programming
     examples are hardware-specific, of course, but you can adapt the
     table-driven character generator described here for use with other
     computers and in other graphics applications.


Character Definition Tables


     Every character that an IBM video subsystem displays is made up of a
     pattern of contiguous pixels. The pixels are arranged to appear as
     coherent, recognizable characters on the screen. The pixel pattern
     that represents a character is the same no matter where in the buffer
     or on the screen the character is located.

     The most convenient way to describe the pixel patterns that represent
     the characters in a character set is to create a table in which bit
     patterns represent the pixel patterns. Such a character definition
     table contains a bit pattern for every displayable character (see
     Figure 9-1). Each character's bit pattern is defined within a
     rectangular matrix. When the character matrix is the same size for all
     characters in the table, and the definitions in the table are
     organized by character code, converting a character code to an offset
     into the table is easy.

     You can use a character definition table formatted in this way in
     alphanumeric as well as graphics modes in video subsystems that
     support RAM-based alphanumeric character definitions. Chapter 10
     covers this topic in detail.


                                           Hex    Binary  ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
                                       ÚÄÄÄ7E    01111110 ³ ³Û³Û³Û³Û³Û³Û³ ³
                                       ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
                                       ³   81    10000001 ³Û³ ³ ³ ³ ³ ³ ³Û³
FOOO:FA6E  00 00 00 00 00 00 00 00     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
          ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   A5    10100101 ³Û³ ³Û³ ³ ³Û³ ³Û³
FOOO:FA76 ³7E 81 A5 81 BD 99 81 7E                        ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
          ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   81    10000001 ³Û³ ³ ³ ³ ³ ³ ³Û³
FOOO:FA7E  7E FF DB FF C3 E7 FF 7E     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
FOOO:FA86  6C FE FE FE 7C 38 10 00     ³   B0    10111101 ³Û³ ³Û³Û³Û³Û³ ³Û³
FOOO:FA8E  10 38 7C FE 7C 38 10 00     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
FOOO:FA96  38 7C 38 FE FE 7C 38 7C     ³   99    10011001 ³Û³ ³ ³Û³Û³ ³ ³Û³
FOOO:FA9E  10 10 38 7C FE 7C 38 7C     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
FOOO:FAA6  00 00 18 3C 3C 18 00 00     ³   81    10000001 ³Û³ ³ ³ ³ ³ ³ ³Û³
FOOO:FAAE  FF FF E7 C3 C3 E7 FF FF     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
                    .                  ÀÄÄÄ7E    01111110 ³ ³Û³Û³Û³Û³Û³Û³ ³
                    .                                     ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ
                    .

     Figure 9-1.  The beginning of the bit patterns that define IBM's ROM
     BIOS 8-by-8 character definitions.


Video BIOS Support

     The PC and PS/2 ROM BIOS contains default character definition tables
     for use in graphics modes. The size of the characters in the table
     depends on the vertical resolution of the video mode. In 200-line,
     CGA-compatible video modes, the default character matrix is 8 pixels
     wide and 8 pixels high; in 350-line graphics modes, it is 8 wide by 14
     high; in 400-line and 480-line modes, it is 8 by 16. In all graphics
     modes, the default characters are 8 pixels wide simply because there
     are 8 bits in a byte. Because each byte in a character definition
     table represents 8 horizontal pixels, defining characters as a
     multiple of 8 pixels in width makes the table easy to manipulate in
     software.

     No equivalent constraint applies to the height of characters defined
     in a character definition table. In practice, however, the character
     matrix used with IBM video subsystems should rarely be smaller than 8
     by 6 pixels or larger than 8 by 16 pixels. With a character matrix
     outside this range, the displayed height and width of the characters
     become disproportionate and the characters tend to appear too short or
     too elongated to be easily read.


     Default CGA Characters
     Figure 9-1 shows the beginning of the character definition table for
     the default character set in CGA graphics modes. The table contains an
     8-byte definition for each of the first 128 ASCII characters (0
     through 7FH). The first eight bytes of the table correspond to
     character code 0, the second eight bytes to character code 1, and so
     forth. The bit pattern in each group of eight bytes represents the
     pixel pattern displayed for the corresponding row of pixels in the
     character. The first of the eight bytes in each group corresponds to
     the topmost row of eight pixels.

     This table of 8-by-8 character definitions is located at F000:FA6E in
     the motherboard ROM on all PCs and PS/2s. However, the table defines
     only the first 128 ASCII characters. Character definitions for the
     second group of 128 ASCII codes (80H through 0FFH) are found in a
     table whose address is stored in interrupt vector 1FH (0000:007C).
     Because the motherboard BIOS contains no definitions for these
     characters, the address is initialized to 0000:0000. If you use the
     ROM BIOS to display ASCII characters between 80H and 0FFH in CGA
     graphics modes without pointing this interrupt vector to a character
     definition table, the "characters" you see on the screen are whatever
     binary patterns happen to lie in the first 1024 bytes of RAM.

       ÉÍÍÍ»     The MS-DOS utility GRAFTABL leaves a table of definitions
       º T º     for characters 80H through 0FFH resident in RAM and
       º I º     updates the interrupt 1FH vector to point to it. The
       º P º     characters defined in GRAFTABL are the same as those the
       ÈÍÍÍ¼     alphanumeric character generator displays for ASCII codes
                 80H through 0FFH.


     Default EGA, VGA, and MCGA Characters
     The ROM BIOS in the EGA, VGA, and MCGA subsystems contains definitions
     for all 256 ASCII codes for all graphics modes. (You can access these
     tables directly; their addresses may be obtained by calling INT 10H
     function 11H with AL = 30H.) When you select a graphics mode with INT
     10H function 0, the video BIOS loads the address of the appropriate
     character definition table for the graphics mode into interrupt vector
     43H (0000:010C). In CGA-compatible 200-line graphics modes, the BIOS
     also points the interrupt 1FH vector to the definitions for characters
     80H through  0FFH.


Creating a Character Definition Table

     The easiest way to obtain a character definition table is to use one
     of the default BIOS tables. If the staid, placid characters in those
     tables aren't to your liking, you can find many others commercially
     available or in the public domain.

       ÉÍÍÍ»     Several standard character sets are defined and registered
       º T º     with the International Standards Organization (ISO). IBM
       º I º     refers to these character sets as code pages and has
       º P º     assigned arbitrary identification numbers to them. For
       ÈÍÍÍ¼     example, the standard IBM PC ASCII character set is
                 designated by code page 437; the Canadian French code page
                 is 863; and code page 850 is the general-purpose
                 "multilingual" character set devised by IBM for languages
                 that use a Latin alphabet.

                 Both MS-DOS (starting in version 3.3) and OS/2 allow
                 applications to switch between code pages on an EGA or
                 VGA. When a program displays characters with operating
                 system function calls, the operating system uses the
                 character definitions in the currently selected code page.
                 Applications that use foreign language character sets
                 should, whenever possible, exploit the code pages
                 supported by the operating system.


     When you define your own character set, you can select among several
     alternative methods. The ugly alternative is to build your character
     definition table by specifying every byte in source code. Figure 9-2
     shows the beginning of such a table. A more elegant alternative is to
     use a character-set editing program. With such editors, you use
     cursor-control keys or a pointing device such as a light pen or mouse
     to specify the bit patterns in the table. Character-set editors are
     also available both commercially and in the public domain. (You can
     even write your own, using the routines in this book.)

     Another approach is to start with one of the BIOS character sets and
     transform the bit patterns in a regular way. For example, you could
     reverse the bit patterns in a table by converting 0s to 1s and 1s to
     0s (that is, apply a bitwise logical NOT to each byte in the table),
     thus creating a "reverse" character set.


     CharDefs    db   000h,000h,000h,000h,000h,000h,000h,000h ; character 0
                 db   03Ch,066h,0C0h,0C0h,0C0h,066h,03Ch,000h ; character 1
                 db   0FCh,066h,066h,07Ch,06Ch,066h,0E6h,000h ; character 2
                 db   0FEh,062h,068h,078h,068h,062h,0FEh,000h ; character 3
                 db   078h,0CCh,0CCh,078h,0CCh,0CCh,078h,000h ; character 4
                 db   078h,030h,030h,030h,030h,030h,078h,000h ; character 5
                 db   0CCh,0CCh,0CCh,0CCh,0CCh,078h,030h,000h ; character 6
                 db   0FEh,062h,068h,078h,068h,062h,0FEh,000h ; character 7
                                      .
                                      .
                                      .

     Figure 9-2.  A hand-coded character definition table.


Software Character Generators


     A software routine that uses the bit patterns in a character
     definition table to draw characters in the video buffer is called a
     software character generator. A software character generator performs
     several functions. It locates the bit pattern for a given character
     code, translates the bit pattern into a corresponding pattern of
     pixels, and updates pixels at a specified location in the video
     buffer.


Video BIOS Support

     The video BIOS provides a software character generator that is used
     whenever INT 10H functions 09H, 0AH, 0EH, and 13H are called in
     graphics modes. The software character generator in the IBM PC and AT
     uses only the 8-by-8 characters defined at F000:FA6E and at the
     address indicated by interrupt vector 1FH. The version in the EGA and
     PS/2 BIOS uses the table to which interrupt vector 43H points; this
     version determines the height of displayed characters from the BIOS
     variable POINTS at 0040:0085.

     You can use the BIOS software character generator to display
     characters from any character definition table by updating the
     appropriate interrupt vectors with the address of the table. On the
     EGA and PS/2s, use INT 10H function 11H to do this.

     The BIOS character generator is convenient to use, but it is somewhat
     limited in its capabilities. In particular, it can only store byte-
     aligned characters in the video buffer. If you are willing to
     sacrifice compatibility with the INT 10H interface, you can write a
     faster software character generator that is more powerful than the
     default video BIOS version.


Pixel Handling

     You store characters in the video buffer by changing the values of the
     appropriate pixel groups. You can update the video buffer simply by
     replacing old pixel values with new ones. You can also perform bitwise
     logical operations (AND, OR, or XOR) to update the pixels.

     Your routine to display text in graphics modes can handle the
     background pixels in the character matrix in one of two ways. One is
     to preserve the contents of the video buffer as much as possible by
     updating only foreground pixels; that is, by updating only those
     pixels that represent the character itself (see Figure 9-3a). The
     other is to update all foreground and background pixels within the
     bounds of the rectangular character matrix (see Figure 9-3b).


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 9-3 is found on page 272       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 9-3.  Characters written without background pixels (a.) and
     with background pixels (b.).


     Updating only the character's foreground pixels preserves as many
     pixels in the video buffer as possible. This may be the best way to
     display text in front of a detailed or patterned graphics image.
     However, reading the displayed characters can be difficult if the
     graphics image in some way blends with the character. For example,
     text is invisible against a region filled with pixels having the same
     value as the character's foreground pixels.

     To avoid such problems, you can update all foreground and background
     pixels in the character matrix each time you store a character in the
     buffer. This avoids a background pattern inadvertently masking the
     characters. The trade-off is that each time you store a character in
     the buffer you must replace the previous contents of the buffer with a
     rectangular blot.

     The source code for the two types of graphics text routines is
     similar. The examples in this chapter demonstrate the second type,
     which makes them more complicated than routines that draw only
     foreground pixels. You can convert the routines to draw only the
     foreground pixels by eliminating the code for incorporating the
     background pixels.


Designing a Software Character Generator


     Software character generators for IBM PC video subsystems have a
     number of design considerations in common. Because the performance of
     your character generator strongly influences the overall performance
     of many graphics applications, always consider the trade-offs between
     function and simplicity in your character generator routines.


Horizontal Alignment

     In graphics modes, the left edge of a character is not necessarily
     byte-aligned. When a character is written so that its leftmost pixels
     fall somewhere in the middle of a byte in the video buffer (see Figure
     9-4a), the character generator must shift and mask the character
     matrix so that only pixels that are part of the character are updated.

     Usually, however, characters are written into the video buffer at
     byte-aligned pixel addresses (see Figure 9-4b). This is the case, for
     example, whenever the display is used in a "teletype mode"; that is,
     when each line of characters starts at the left edge of the display.
     Generating byte-aligned characters requires no rotation or masking of
     pixels, so using a separate routine for byte-aligned characters
     improves the character generator's performance.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 9-4 is found on page 273       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 9-4.  Alignment of characters in the video buffer. In Figure
     9-4a, characters are not aligned; in Figure 9-4b, characters are byte-
     aligned.


Variable Character Sizes

     Writing a character generator that accommodates characters of
     different heights is relatively easy. The height of a character
     corresponds to the number of bytes in its definition in the character
     definition table. You can thus use the height of your characters as a
     loop limit inside the character generator routine without
     significantly affecting the complexity of the routine.

     Handling characters of different widths is more difficult. If the
     width of a character does not fit exactly into an integer number of
     bytes, you must mask each row of pixels in the character as you store
     it in the video buffer. Again, the extra overhead of forming the
     appropriate bit mask and masking pixels in the video buffer
     complicates and slows the character generator routine.


Clipping

     You can clip characters in several ways. The simplest is to clip the
     entire character before you store it in the video buffer; if any
     portion of the character matrix would lie outside the clipping area,
     don't write the character.

     Clipping a character so that only a portion of it is stored in the
     video buffer is more difficult. One way to do this is to modify the
     character generator so that any clipped portion of a character is not
     written to the buffer. Another approach is to write the entire
     character into an auxiliary buffer and then copy the clipped character
     into the video buffer with a pixel block copy routine (see Chapter
     11).


Character Orientation

     Usually, characters are displayed so that they can be read from left
     to right and from the top down. To change this orientation, apply the
     appropriate transformation to the bit patterns in the character
     definition table. For example, the subroutine in Listing 9-1 rotates
     the 8-byte bit pattern that represents an 8-by-8 character so that the
     displayed characters read upward. With this transformation, you can
     use the same character generator to display vertically or horizontally
     oriented characters. Only the bit patterns differ.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-1.  A routine that rotates an 8-by-8 character
     definition by 90 degrees.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Cooperating with the Video BIOS

     Even if your character definition tables and character generator
     software avoid using video BIOS functions, you should nevertheless try
     to preserve compatibility by cooperating with the BIOS routines when
     possible. In 200-line graphics modes, you should update the address in
     interrupt vector 1FH whenever you use an 8-by-8 character definition
     table that includes the second 128 ASCII characters. On the EGA, VGA,
     and MCGA, you should generally use INT 10H function 11H to keep the
     BIOS interrupt vectors and Video Display Data Area variables up to
     date.


More Power, More Complexity

     You can add functionality to a software character generator in several
     ways. You might, for example, write a character generator that refers
     to a table of relative character widths to display proportionally
     spaced characters. As your routine reads bit patterns from the
     character definition table, you might have it shift them to the right
     by a predetermined number of pixels to generate bold or italic
     character sets. You might apply a pattern of pixel values to the
     foreground pixels you update. You might allow a character definition
     table to extend beyond the usual range of 256 characters; the more
     characters you define, the wider range of characters you can display
     at one time. Any of these possibilities adds power and flexibility to
     your software character generator, but all of them complicate your
     source code and ultimately slow it down.


Implementing a Software Character Generator


     All software character generator examples in this chapter require that
     you specify the x- and y-coordinates of the pixel in the upper left
     corner of the displayed character matrix. Each routine detects the
     special case where the character matrix is byte-aligned in the video
     buffer, but the routines do not validate pixel coordinates or perform
     any clipping. All the routines except DisplayChar10() update pixels in
     the video buffer by replacing their values. To perform a bitwise AND,
     OR, or XOR operation, you must modify the routines (see Chapter 5).


CGA

     In 640-by-200 2-color mode on the CGA, the software character
     generator applies the bit patterns in the character definition table
     directly to the pixels in the video buffer (see Listing 9-2). When
     the character is byte-aligned in the video buffer, the routine copies
     pixel values directly from the character definition table. Otherwise,
     for each row of eight pixels in the character, a rotated 16-bit mask
     is used to zero the proper eight pixels in the buffer. Then the pixels
     from the character definition table are rotated into position and
     stored in the buffer using a bitwise OR operation.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-2.  A software character generator for 640-by-200 2-color
     mode.

		TITLE	'Listing 9-3'
		NAME	DisplayChar06
		PAGE	55,132

;
; Name:		DisplayChar06
;
; Function:	Display a character in 640x200 2-color mode
;
; Caller:	Microsoft C:
;
;			void DisplayChar06(c,x,y,fgd,bkgd);
;
;			int c;			/* character code */
;
;			int x,y;		/* upper left pixel */
;
;			int fgd,bkgd;		/* foreground and background
;						    pixel values */
;

ARGc		EQU	word ptr [bp+4]	; stack frame addressing
ARGx		EQU	word ptr [bp+6]
ARGy		EQU	word ptr [bp+8]
ARGfgd		EQU	byte ptr [bp+10]
ARGbkgd		EQU	byte ptr [bp+12]

VARmask		EQU	[bp-2]
VARtoggle	EQU	[bp-4]


_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT

		EXTRN	PixelAddr06:near

		PUBLIC	_DisplayChar06
_DisplayChar06	PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		sub	sp,4		; stack space for local variables
		push	si
		push	di
		push	ds

; set up foreground pixel toggle mask

		mov	ah,ARGfgd	; AH := 0 or 1 (foreground pixel value)
		ror	ah,1		; high-order bit of AH := 0 or 1
		cwd			; propagate high-order bit through DX
		not	dx		; DX :=     0 if foreground = 1
					;    or FFFFh if foreground = 0
		mov	VARtoggle,dx

; calculate first pixel address

		mov	ax,ARGy		; AX := y
		mov	bx,ARGx		; BX := x
		call	PixelAddr06	; ES:BX -> buffer
					; CL := # bits to shift left

		xor	cl,7		; CL := # bits to rotate right

		mov	ax,0FF00h
		ror	ax,cl		; AX := bit mask in proper position
		mov	VARmask,ax

; set up video buffer addressing

		mov	dx,2000h	; increment for video buffer interleave
		mov	di,80-2000h	; increment from last to first interleave

		test	bx,2000h	; set zero flag if BX in 1st interleave
		jz	L01

		xchg	di,dx		; exchange increment values if 1st pixel
					;  lies in 1st interleave

; set up character definition table addressing

L01:		push	bx		; preserve buffer address

		mov	ax,40h
		mov	ds,ax		; DS := segment of BIOS Video
					;  Display Data area
		mov	ch,ds:[85h]	; CH := POINTS (pixel rows in character)

		xor	ax,ax
		mov	ds,ax		; DS := absolute zero

		mov	ax,ARGc		; AL := character code
		cmp	al,80h
		jae	L02

		mov	bx,43h*4	; DS:BX -> int 43h vector if char < 80h
		jmp	short L03

L02:		mov	bx,1Fh*4	; DS:BX -> int 1Fh vector if char >= 80h
		sub	al,80h		; put character code in range of table 

L03:		lds	si,ds:[bx]	; DS:SI -> start of character table
		mul	ch		; AX := offset into char def table
					;  (POINTS * char code)
		add	si,ax		; SI := addr of char def

		pop	bx		; restore buffer address

		test	cl,cl		; test # bits to rotate
		jnz	L20		; jump if character is not byte-aligned


; routine for byte-aligned characters

		mov	ah,VARtoggle	; AH := foreground toggle mask
		xchg	ch,cl		; CX := POINTS
		
L10:		lodsb			; AL := bit pattern for next pixel row
		xor	al,ah		; toggle pixels if foreground = 0
		mov	es:[bx],al	; store pixels in buffer

		add	bx,dx		; BX := next row in buffer
		xchg	di,dx		; swap buffer increments
		loop	L10
		jmp	short Lexit


; routine for non-byte-aligned characters

L20:		mov	ax,VARmask
		and	es:[bx],ax	; mask character pixels in buffer

		xor	ah,ah
		lodsb			; AX := bit pattern for next pixel row
		xor	al,VARtoggle	; toggle pixels if foreground = 0

		ror	ax,cl		; rotate pixels into position
		or	es:[bx],ax	; store pixels in buffer

		add	bx,dx		; BX := next row in buffer
		xchg	di,dx		; swap buffer increments
		dec	ch
		jnz	L20


Lexit:		pop	ds		; restore registers and return
		pop	di
		pop	si
		mov	sp,bp
		pop	bp
		ret

_DisplayChar06	ENDP

_TEXT		ENDS

		END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The routine for 320-by-200 4-color mode in Listing 9-3 is more
     complicated because each bit in the character definition must be
     expanded into the appropriate 2-bit pixel value. A 0 bit in the
     character definition table becomes a 2-bit background pixel value; a
     1 bit in the table is expanded into a 2-bit foreground pixel value.
     Thus, each byte in the table is transformed into a word of pixels.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-3.  A software character generator for 640-by-200
     4-color mode.

		TITLE	'Listing 9-3'
		NAME	DisplayChar04
		PAGE	55,132

;
; Name:		DisplayChar04
;
; Function:	Display a character in 320x200 4-color graphics mode
;
; Caller:	Microsoft C:
;
;			void DisplayChar04(c,x,y,fgd,bkgd);
;
;			int c;			/* character code */
;
;			int x,y;		/* upper left pixel */
;
;			int fgd,bkgd;		/* foreground and background
;						    pixel values */
;

ARGc		EQU	word ptr [bp+4]	; stack frame addressing
ARGx		EQU	word ptr [bp+6]
ARGy		EQU	word ptr [bp+8]
ARGfgd		EQU	         [bp+10]
ARGbkgd		EQU	         [bp+12]

VARshift	EQU	word ptr [bp-2]
VARincr		EQU	word ptr [bp-4]


DGROUP		GROUP	_DATA

_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT,ds:DGROUP

		EXTRN	PixelAddr04:near

		PUBLIC	_DisplayChar04
_DisplayChar04	PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		sub	sp,4		; stack space for local variables
		push	si
		push	di
		push	ds

; propagate pixel values

		mov	bx,offset DGROUP:PropagatedPixel
		mov	al,ARGfgd
		xlat			; propagate foreground pixel value
		mov	ah,al
		mov	ARGfgd,ax

		mov	al,ARGbkgd
		xlat			; propagate background pixel value
		mov	ah,al
		mov	ARGbkgd,ax 

; calculate first pixel address

		mov	ax,ARGy		; AX := y
		mov	bx,ARGx		; BX := x
		call	PixelAddr04	; ES:BX -> buffer
					; CL := # bits to shift left
					;  to mask pixel
		mov	ch,0FCh
		shl	ch,cl		; CH := bit mask for right side of char

		xor	cl,6		; CL := 6 - CL (# bits to rotate char
					;  into position)
		mov	VARshift,cx

; set up video buffer addressing

		mov	di,2000h	; increment for video buffer interleave
		mov	VARincr,80-2000h ; increment from last to first interleave

		test	bx,2000h	; set zero flag if BX in 1st interleave
		jz	L01

		xchg	VARincr,di	; exchange increment values if 1st pixel
					;  lies in 1st interleave

; set up character definition table addressing

L01:		push	bx		; preserve buffer address

		mov	ax,40h
		mov	ds,ax		; DS := segment of BIOS Video
					;  Display Data area
		mov	ch,ds:[85h]	; CH := POINTS (pixel rows in character)

		xor	ax,ax
		mov	ds,ax		; DS := absolute zero

		mov	ax,ARGc		; AL := character code
		cmp	al,80h
		jae	L02

		mov	bx,43h*4	; DS:BX -> int 43h vector if char < 80h
		jmp	short L03

L02:		mov	bx,1Fh*4	; DS:BX -> int 1Fh vector if char >= 80h
		sub	al,80h		; put character code in range of table 

L03:		lds	si,ds:[bx]	; DS:SI -> start of character table
		mul	ch		; AX := offset into char def table
					;  (POINTS * char code)
		add	si,ax		; SI := addr of char def

		pop	bx		; restore buffer address

		xchg	ch,cl		; CH := # bits to rotate
					; CL := POINTS
		
		test	ch,ch		; test # bits to rotate
		jnz	L20		; jump if character is not byte-aligned


; routine for byte-aligned characters

L10:		lodsb			; AL := bit pattern for next pixel row
		xor	dx,dx		; DX := initial value for doubled bits
		mov	ah,8		; AH := # of bits in pattern

L11:		shr	al,1		; cf := lo-order bit of AL
		rcr	dx,1		; hi-order bit of CX := cf
		sar	dx,1		; double hi-order bit of DX
		dec	ah		; loop 8 times
		jnz	L11

		mov	ax,dx		; AX,DX := doubled bit pattern
		and	ax,ARGfgd	; AX := foreground pixels
		not	dx
		and	dx,ARGbkgd	; DX := background pixels

		or	ax,dx		; AX := eight pixels
		xchg	ah,al		; put bytes in proper order
		mov	es:[bx],ax	; update video buffer

		add	bx,di		; BX := next row in buffer
		xchg	di,VARincr	; swap buffer increments

		loop	L10
		jmp	short Lexit


; routine for non-byte-aligned characters

L20:		xor	ch,ch		; CX := POINTS

L21:		push	cx		; preserve CX

		mov	cx,VARshift	; CH := mask for right side of char
					; CL := # bits to rotate

		lodsb			; AL := bit pattern for next pixel row
		xor	dx,dx		; DX := initial value for doubled bits
		mov	ah,8		; AH := # of bits in pattern

L22:		shr	al,1		; DX := double bits in AL
		rcr	dx,1		;  (same as above)
		sar	dx,1
		dec	ah
		jnz	L22

		xchg	dh,dl		; DH := bits for right half of char
					; DL := bits for left half of char
		mov	ax,dx
		and	ax,ARGfgd	; AX := foreground pixels
		not	dx
		and	dx,ARGbkgd	; DX := background pixels

		or	dx,ax		; DX := eight pixels
		ror	dx,cl		; DH := left and right side pixels
					; DL := middle pixels
		mov	al,ch
		xor	ah,ah		; AX := mask for left and middle
					;  bytes of char
		and	es:[bx],ax	; zero pixels in video buffer

		not	ax
		and	ax,dx
		or	es:[bx],ax	; update pixels in left and middle bytes

		mov	al,ch		; AL := mask for right-hand byte
		not	al
		and	es:[bx+2],al	; mask pixels in right-hand byte in buffer
		and	ch,dl
		or	es:[bx+2],ch	; update pixels in right-hand byte

		add	bx,di		; BX := next row in buffer
		xchg	di,VARincr	; swap buffer increments

		pop	cx		; restore CX
		loop	L21


Lexit:		pop	ds		; restore registers and return
		pop	di
		pop	si
		mov	sp,bp
		pop	bp
		ret

_DisplayChar04	ENDP

_TEXT		ENDS


_DATA		SEGMENT	word public 'DATA'

PropagatedPixel	DB	00000000b	; 0
		DB	01010101b	; 1
		DB	10101010b	; 2
		DB	11111111b	; 3

_DATA		ENDS

		END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     In Listing 9-3, when the character is byte-aligned in the video
     buffer, the routine moves the 16-bit word of pixels directly into the
     buffer. A character that is not byte-aligned spans three bytes in the
     buffer. In this case, the routine must rotate the eight pixels in each
     row of the character into position. Then the first two bytes of the
     character in the buffer are masked and updated, followed by the third
     (rightmost) byte of the character.


HGC and HGC+

     A routine for the 720-by-348 monochrome graphics mode on the HGC and
     the HGC+ can use the same bit-masking technique that the CGA 640-by-
     200 2-color routine uses. You could convert DisplayChar06() into a
     Hercules-compatible routine by revising the call to PixelAddr06() and
     by changing video buffer addressing to accommodate the different
     buffer interleaves on the two adapters.

     It is worthwhile, however, to exploit the HGC's 720-pixel horizontal
     resolution by displaying characters in a matrix that is 9 pixels wide,
     so that each row on the screen contains 80 evenly spaced characters.
     The routine in Listing 9-4 does this by appending a ninth bit to each
     8-bit pattern it reads from the character definition table. The
     ninth bit is 0 except for box-drawing characters (ASCII 0C0-0DFH).
     For these characters, the ninth bit is a copy of the rightmost
     bit in the bit pattern. (This mimics the function of the hardware
     character generator in alphanumeric modes. See Chapter 10.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-4.  A software character generator for Hercules monochrome
     graphics mode.

		TITLE	'Listing 9-4'
		NAME	DisplayCharHGC
		PAGE	55,132

;
; Name:		DisplayCharHGC
;
; Function:	Display a character in Hercules 720x348 monochrome graphics mode
;
; Caller:	Microsoft C:
;
;			void DisplayCharHGC(c,x,y,fgd,bkgd);
;
;			int c;			/* character code */
;
;			int x,y;		/* upper left pixel */
;
;			int fgd,bkgd;		/* foreground and background
;						    pixel values */
;

ARGc		EQU	word ptr [bp+4]	; stack frame addressing
ARGx		EQU	word ptr [bp+6]
ARGy		EQU	word ptr [bp+8]
ARGfgd		EQU	byte ptr [bp+10]
ARGbkgd		EQU	byte ptr [bp+12]

VARmask		EQU	         [bp-2]
VARtoggle	EQU	         [bp-4]
VAR9bits	EQU	byte ptr [bp-6]


_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT

		EXTRN	PixelAddrHGC:near

		PUBLIC	_DisplayCharHGC
_DisplayCharHGC	PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		sub	sp,6		; stack space for local variables
		push	si
		push	di
		push	ds

; calculate first pixel address

		mov	ax,ARGy		; AX := y
		mov	bx,ARGx		; BX := x
		call	PixelAddrHGC	; ES:BX -> buffer
					; CL := # bits to shift left

		xor	cl,7		; CL := # bits to rotate right

; set up 8- or 9-bit mask

		mov	ax,40h
		mov	ds,ax		; DS := segment of BIOS Video
					;  Display Data area

		mov	ax,0FF00h	; AX := 8-bit mask
		mov	VAR9bits,0	; zero this flag

		cmp	byte ptr ds:[4Ah],90	; does CRT_COLS = 90?
		je	L01		; jump if characters are 8 pixels wide

		mov	ah,7Fh		; AX := 9-bit mask
		cmp	ARGc,0C0h
		jb	L01		; jump if character code ...

		cmp	ARGc,0DFh
		ja	L01		; ... outside of range 0C0-0DFh

		inc	VAR9bits	; set flag to extend to 9 bits

L01:		ror	ax,cl		; AX := bit mask in proper position
		mov	VARmask,ax

; set up foreground pixel toggle mask

		mov	ah,ARGfgd	; AH := 0 or 1 (foreground pixel value)
		ror	ah,1		; high-order bit of AH := 0 or 1
		cwd			; propagate high-order bit through DX
		not	dx		; DX :=     0 if foreground = 1
					;    or FFFFh if foreground = 0
		mov	ax,VARmask
		not	ax
		and	dx,ax		; zero unused bits of toggle mask in DX
		mov	VARtoggle,dx

; set up character definition table addressing

		push	bx		; preserve buffer address

		mov	ch,ds:[85h]	; CH := POINTS (pixel rows in character)

		xor	ax,ax
		mov	ds,ax		; DS := absolute zero

		mov	ax,ARGc		; AL := character code
		cmp	al,80h
		jae	L02

		mov	bx,43h*4	; DS:BX -> int 43h vector if char < 80h
		jmp	short L03

L02:		mov	bx,1Fh*4	; DS:BX -> int 1Fh vector if char >= 80h
		sub	al,80h		; put character code in range of table 

L03:		lds	si,ds:[bx]	; DS:SI -> start of character table
		mul	ch		; AX := offset into char def table
					;  (POINTS * char code)
		add	si,ax		; SI := addr of char def

		pop	bx		; restore buffer address

; mask and set pixels in the video buffer

L20:		mov	ax,VARmask
		and	es:[bx],ax	; mask character pixels in buffer

		xor	ah,ah
		lodsb			; AX := bit pattern for next pixel row
		cmp	VAR9bits,0
		je	L21		; jump if character is 8 pixels wide

		ror	ax,1		; copy lo-order bit of AX into ...
		rcl	al,1		;  hi-order bit

L21:		ror	ax,cl		; rotate pixels into position
		xor	ax,VARtoggle	; toggle pixels if foreground = 0
		or	es:[bx],ax	; store pixels in buffer

		add	bx,2000h	; increment to next portion of interleave
		jns	L22

		add	bx,90-8000h	; increment to first portion of interleave

L22:		dec	ch
		jnz	L20


Lexit:		pop	ds		; restore registers and return
		pop	di
		pop	si
		mov	sp,bp
		pop	bp
		ret

_DisplayCharHGC	ENDP

_TEXT		ENDS

		END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     Note how the CGA and Hercules routines use interrupt
       º T º     vector 43H to point to the start of the current character
       º I º     definition table. This is the interrupt vector the EGA and
       º P º     VGA ROM BIOS uses for this purpose. Also, the routines
       ÈÍÍÍ¼     determine the size of the displayed character matrix by
                 inspecting the variables POINTS (0040:0085) and CRT_COLS
                 (0040:004A) in the BIOS Video Display Data Area. If you
                 are not using an EGA, MCGA, or VGA, the BIOS won't keep
                 the interrupt vector and POINTS up to date; in this case,
                 your program should either update these values explicitly
                 or maintain equivalent values elsewhere.


MCGA

     In 640-by-480 2-color mode on the MCGA, pixels are stored eight to a
     byte, so you can adapt the 640-by-200 2-color character generator for
     use in this mode by modifying its video buffer addressing. A character
     generator for 320-by-200 256-color mode is a little different, because
     each bit in the character definition table expands into a byte in the
     video buffer (see Listing 9-5).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-5.  A character generator for MCGA and VGA 320-by-200 256-
     color mode.

		TITLE	'Listing 9-5'
		NAME	DisplayChar13
		PAGE	55,132

;
; Name:		DisplayChar13
;
; Function:	Display a character in MCGA/VGA 320x200 256-color mode
;
; Caller:	Microsoft C:
;
;			void DisplayChar13(c,x,y,fgd,bkgd);
;
;			int c;			/* character code */
;
;			int x,y;		/* upper left pixel */
;
;			int fgd,bkgd;		/* foreground and background
;						    pixel values */
;

ARGc		EQU	word ptr [bp+4]	; stack frame addressing
ARGx		EQU	word ptr [bp+6]
ARGy		EQU	word ptr [bp+8]
ARGfgd		EQU	byte ptr [bp+10]
ARGbkgd		EQU	byte ptr [bp+12]

BytesPerLine	EQU	320

_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT

		EXTRN	PixelAddr13:near

		PUBLIC	_DisplayChar13
_DisplayChar13	PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		push	si
		push	di
		push	ds

; calculate first pixel address

		mov	ax,ARGy		; AX := y
		mov	bx,ARGx		; BX := x
		call	PixelAddr13	; ES:BX -> buffer
		mov	di,bx		; ES:DI -> buffer

; set up character definition table addressing

		mov	ax,40h
		mov	ds,ax		; DS := segment of BIOS Video
					;  Display Data area
		mov	cx,ds:[85h]	; CX := POINTS (pixel rows in character)

		xor	ax,ax
		mov	ds,ax		; DS := absolute zero

		mov	ax,ARGc		; AL := character code
		mov	bx,43h*4	; DS:BX -> int 43h vector if char < 80h
		lds	si,ds:[bx]	; DS:SI -> start of character table
		mul	cl		; AX := offset into char def table
					;  (POINTS * char code)
		add	si,ax		; SI := addr of char def
		
; store the character in the video buffer

		mov	bl,ARGfgd	; BL := foreground pixel value
		mov	bh,ARGbkgd	; BH := background pixel value

L10:		push	cx		; preserve CX across loop
		mov	cx,8		; CX := character width in pixels
		lodsb
		mov	ah,al		; AH := bit pattern for next pixel row

L11:		mov	al,bl		; AL := foreground pixel value
		shl	ah,1		; carry flag := high-order bit
		jc	L12		; jump if bit pattern specifies a
					;  foreground pixel (bit = 1)
		mov	al,bh		; AL := background pixel value

L12:		stosb			; update one pixel in the buffer
		loop	L11

		add	di,BytesPerLine-8 ; increment buffer address to next
					  ;  row of pixels
		pop	cx
		loop	L10		; loop down character

		pop	ds		; restore registers and return
		pop	di
		pop	si
		mov	sp,bp
		pop	bp
		ret

_DisplayChar13	ENDP

_TEXT		ENDS

		END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


EGA and VGA

     The routine for the EGA and VGA in Listing 9-6 uses the Graphics
     Controller to update pixels in the video buffer. The routine is
     similar in some ways to the routine for the CGA's 640-by-200 2-color
     mode, because each byte of the video buffer represents eight pixels.
     Of course, the code is complicated by the need to program the Graphics
     Controller to handle the foreground and background pixel values.

     The routine writes each row of pixels in the character by latching the
     bit planes, updating the foreground pixels, updating the background
     pixels, and then writing the latches back to the bit planes. The
     Graphics Controller cannot conveniently update both foreground and
     background pixels at the same time, so the routine must perform these
     operations separately.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-6.  A software character generator for native EGA and VGA
     graphics modes.

		TITLE	'Listing 9-6'
		NAME	DisplayChar10
		PAGE	55,132

;
; Name:		DisplayChar10
;
; Function:	Display a character in native EGA and VGA graphics modes
;
; Caller:	Microsoft C:
;
;			void DisplayChar10(c,x,y,fgd,bkgd);
;
;			int c;			/* character code */
;
;			int x,y;		/* upper left pixel */
;
;			int fgd,bkgd;		/* foreground and background
;						    pixel values */
;

ARGc		EQU	word ptr [bp+4]	; stack frame addressing
ARGx		EQU	word ptr [bp+6]
ARGy		EQU	word ptr [bp+8]
ARGfgd		EQU	byte ptr [bp+10]
ARGbkgd		EQU	byte ptr [bp+12]

VARshift	EQU	         [bp-2]

BytesPerLine	=	80		; (must 40 in 320x200 16-color mode)
RMWbits		=	18h		; Read-Modify-Write bits

_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT

		EXTRN	PixelAddr10:near

		PUBLIC	_DisplayChar10
_DisplayChar10	PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		sub	sp,2		; stack space for local variable
		push	si
		push	di
		push	ds

; calculate first pixel address

		mov	ax,ARGy		; AX := y
		mov	bx,ARGx		; BX := x
		call	PixelAddr10	; ES:BX -> buffer
					; CL := # bits to shift left to mask
					;  pixel
		inc	cx
		and	cl,7		; CL := # bits to shift to mask char

		mov	ch,0FFh
		shl	ch,cl		; CH := bit mask for right side of char
		mov	VARshift,cx

		push	es		; preserve video buffer segment
		mov	si,bx		; SI := video buffer offset

; set up character definition table addressing

		mov	ax,40h
		mov	ds,ax		; DS := segment of BIOS Video
					;  Display Data area
		mov	cx,ds:[85h]	; CX := POINTS (pixel rows in character)

		xor	ax,ax
		mov	ds,ax		; DS := absolute zero

		mov	ax,ARGc		; AL := character code
		mov	bx,43h*4	; DS:BX -> int 43h vector
		les	di,ds:[bx]	; ES:DI -> start of character table
		mul	cl		; AX := offset into char def table
					;  (POINTS * char code)
		add	di,ax		; DI := addr of char def

		pop	ds		; DS:SI -> video buffer

; set up Graphics Controller registers

		mov	dx,3CEh		; Graphics Controller address reg port

		mov	ax,0A05h	; AL :=  Mode register number
					; AH :=  Write Mode 2 (bits 0-1)
					;	 Read Mode 1 (bit 4)
		out	dx,ax

		mov	ah,RMWbits	; AH := Read-Modify-Write bits
		mov	al,3		; AL := Data Rotate/Function Select reg
		out	dx,ax

		mov	ax,0007		; AH := Color Don't Care bits
					; AL := Color Don't Care reg number
		out	dx,ax		; "don't care" for all bit planes 

; select output routine depending on whether character is byte-aligned

		mov	bl,ARGfgd	; BL := foreground pixel value
		mov	bh,ARGbkgd	; BH := background pixel value

		cmp	byte ptr VARshift,0   ; test # bits to shift
		jne	L20		; jump if character is not byte-aligned


; routine for byte-aligned characters

		mov	al,8		; AL := Bit Mask register number 

L10:		mov	ah,es:[di]	; AH := pattern for next row of pixels
		out	dx,ax		; update Bit Mask register
		and	[si],bl		; update foreground pixels

		not	ah
		out	dx,ax
		and	[si],bh		; update background pixels

		inc	di		; ES:DI -> next byte in char def table
		add	si,BytesPerLine	; increment to next line in video buffer
		loop	L10
		jmp	short Lexit


; routine for non-byte-aligned characters

L20:		push	cx		; preserve loop counter
		mov	cx,VARshift	; CH := mask for left side of character
					; CL := # bits to shift left
; left side of character

		mov	al,es:[di]	; AL := bits for next row of pixels
		xor	ah,ah
		shl	ax,cl		; AH := bits for left side of char
					; AL := bits for right side of char
		push	ax		; save bits for right side on stack
		mov	al,8		; AL := Bit Mask Register number
		out	dx,ax		; set bit mask for foreground pixels

		and	[si],bl		; update foreground pixels

		not	ch		; CH := mask for left side of char
		xor	ah,ch		; AH := bits for background pixels
		out	dx,ax		; set bit mask

		and	[si],bh		; update background pixels

; right side of character

		pop	ax
		mov	ah,al		; AH := bits for right side of char
		mov	al,8
		out	dx,ax		; set bit mask

		inc	si		; DS:SI -> right side of char in buffer

		and	[si],bl		; update foreground pixels

		not	ch		; CH := mask for right side of char
		xor	ah,ch		; AH := bits for background pixels
		out	dx,ax		; set bit mask

		and	[si],bh		; update background pixels

; increment to next row of pixels in character

		inc	di		; ES:DI -> next byte in char def table
		dec	si
		add	si,BytesPerLine	; DS:SI -> next line in video buffer

		pop	cx
		loop	L20


; restore default Graphics Controller registers

Lexit:		mov	ax,0FF08h	; default Bit Mask
		out	dx,ax

		mov	ax,0005		; default Mode register
		out	dx,ax

		mov	ax,0003		; default Data Rotate/Function Select
		out	dx,ax

		mov	ax,0F07h	; default Color Don't Care
		out	dx,ax

		pop	ds		; restore caller registers and return
		pop	di
		pop	si
		mov	sp,bp
		pop	bp
		ret

_DisplayChar10	ENDP

_TEXT		ENDS

		END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


InColor Card

     The technique for storing characters in the video buffer on the
     Hercules InColor Card, shown in Listing 9-7, is different from that
     on the EGA or VGA because you can use the InColor Card's Read/Write
     Color register (1AH) and write mode 0 to update both foreground and
     background pixel values in one operation. Thus, the actual process of
     updating the bit planes collapses into relatively few machine
     instructions.

     However, the InColor Card cannot perform pixel AND, OR, or XOR
     operations in hardware. To do this, you must write additional
     subroutines that use the Plane Mask register to map logical operations
     onto the bit planes (see Chapter 5).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-7.  A software character generator for Hercules InColor
     graphics modes.

		TITLE	'Listing 9-7'
		NAME	DisplayCharInC
		PAGE	55,132

;
; Name:		DisplayCharInC
;
; Function:	Display a character in InColor 720x348 16-color mode
;
; Caller:	Microsoft C:
;
;			void DisplayCharInC(c,x,y,fgd,bkgd);
;
;			int c;			/* character code */
;
;			int x,y;		/* upper left pixel */
;
;			int fgd,bkgd;		/* foreground and background
;						    pixel values */
;

ARGc		EQU	word ptr [bp+4]	; stack frame addressing
ARGx		EQU	word ptr [bp+6]
ARGy		EQU	word ptr [bp+8]
ARGfgd		EQU	byte ptr [bp+10]
ARGbkgd		EQU	byte ptr [bp+12]

VARmask		EQU	word ptr [bp-2]
VAR9bits	EQU	byte ptr [bp-4]

_TEXT		SEGMENT	byte public 'CODE'
		ASSUME	cs:_TEXT

		EXTRN	PixelAddrHGC:near

		PUBLIC	_DisplayCharInC
_DisplayCharInC	PROC	near

		push	bp		; preserve caller registers
		mov	bp,sp
		sub	sp,4		; stack space for local variables
		push	si
		push	di
		push	ds

; calculate first pixel address

		mov	ax,ARGy		; AX := y
		mov	bx,ARGx		; BX := x
		call	PixelAddrHGC	; ES:BX -> buffer
					; CL := # bits to shift left to mask
					;  pixel
		xor	cl,7		; CL := # bits to rotate right

		push	es		; preserve video buffer segment
		mov	si,bx		; DI := video buffer offset

; set up flag for 8- or 9-bit characters

		mov	ax,40h
		mov	ds,ax		; DS := segment of BIOS Video
					;  Display Data area

		mov	ax,0FF00h	; AX := 8-bit mask
		mov	VAR9bits,0	; zero this flag

		cmp	byte ptr ds:[4Ah],90	; does CRT_COLS = 90?
		je	L01		; jump if characters are 8 pixels wide

		mov	ah,7Fh		; AX := 9-bit mask
		cmp	ARGc,0C0h
		jb	L01		; jump if character code ...

		cmp	ARGc,0DFh
		ja	L01		; ... outside of range 0C0-0DFh

		inc	VAR9bits	; set flag to extend to 9 bits

L01:		ror	ax,cl		; AX := bit mask in proper position
		mov	VARmask,ax

; set up character definition table addressing

		mov	ax,40h
		mov	ds,ax		; DS := segment of BIOS Video
					;  Display Data area
		mov	ch,ds:[85h]	; CH := POINTS (pixel rows in character)

		xor	ax,ax
		mov	ds,ax		; DS := absolute zero

		mov	ax,ARGc		; AL := character code
		cmp	al,80h
		jae	L02

		mov	bx,43h*4	; DS:BX -> int 43h vector if char < 80h
		jmp	short L03

L02:		mov	bx,1Fh*4	; DS:BX -> int 1Fh vector if char >= 80h
		sub	al,80h		; put character code in range of table 

L03:		les	di,ds:[bx]	; ES:DI -> start of character table
		mul	ch		; AX := offset into char def table
					;  (POINTS * char code)
		add	di,ax		; DI := addr of char def

		pop	ds		; DS:SI -> video buffer

; set up control registers

		mov	dx,3B4h		; control register I/O port

		push	cx		; preserve CX
		mov	ah,ARGbkgd	; AH := background pixel value
		mov	cl,4
		shl	ah,cl		; AH bits 4-7 := background pixel value
		or	ah,ARGfgd	; AH bits 0-3 := foreground pixel value
		pop	cx		; restore CX

		mov	al,1Ah		; AL := Read/Write Color reg number
		out	dx,ax		; set Read/Write Color value

; mask and set pixels in the video buffer

L20:		xor	bh,bh
		mov	bl,es:[di]	; BX := bit pattern for next pixel row
		inc	di		; increment pointer to char def table
		cmp	VAR9bits,0

		je	L21		; jump if character is 8 pixels wide

		ror	bx,1		; copy lo-order bit of BX into ...
		rcl	bl,1		;  hi-order bit

L21:		ror	bx,cl		; rotate pixels into position

		mov	ax,5F19h	; AH bit 6 := 1 (mask polarity)
					; AH bits 4-5 := 01b (write mode 1)
					; AH bits 0-3 := 1111b (don't care bits)
					; AL := 19h (Read/Write Control reg)
		out	dx,ax		; set up Read/Write control reg

		or	[si],bl		; update foreground pixels
		or	[si+1],bh

		mov	ah,6Fh		; set up write mode 2
		out	dx,ax

		or	bx,VARmask	; BX := background pixel bit pattern
		or	[si],bl		; update background pixels
		or	[si+1],bh

		add	si,2000h	; increment to next portion of interleave
		jns	L22

		add	si,90-8000h	; increment to first portion of interleave

L22:		dec	ch
		jnz	L20

; restore default InColor register values

		mov	ax,4019h	; default Read/Write Control reg
		out	dx,ax

		mov	ax,071Ah	; default Read/Write Color reg
		out	dx,ax

		pop	ds		; restore registers and return
		pop	di
		pop	si
		mov	sp,bp
		pop	bp
		ret

_DisplayCharInC	ENDP

_TEXT		ENDS

		END


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
